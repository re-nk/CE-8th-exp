\chapter{T6 - Aprimoramento de uma Simulação: Laboratório e Experimento virus\_on\_network, por Paulo Mauricio Costa Lopes (RequiemDosVivos)\label{desenho:experimento:jhcf}}

\section{Introdução}



O modelo que será objeto de estudo neste trabalho é o de \textbf{virus\_on\_network}
“A virus model with some
number of agents entering in contact through a network of relations”, um modelo multi-agente de conexão e infecção para COVID-19. Esse trabalho foi adaptado para ser usado em infecção de conectividade de computadores.  



O estudo a seguir é composto pelas seguintes seções: 
\begin{enumerate}
    \item Descrição do fenômeno real;
    \item Apresentação do laboratório de simulações;
    \item Apresentação de análises exploratórias dos dados de experimentos realizados com o uso do laboratório;
    \item Discussão sobre \textit{insights} obtidos após os experimentos; e
    \item Conclusões.
\end{enumerate}

\section{O Fenômeno do Mundo Real}


O fenômeno trabalhado no estudo a seguir trata-se da infecção por vírus em uma rede de computadores e as subsequentes interações que podem ser observadas na interação entre os dispositivos dentro dela. Diversas redes podem estar suscetíveis a este cenário diariamente caso haja a possibilidade de um componente dela ser infectado.

Este tipo de contágio por malwares pode acontecer em dispositivos na mesma rede de forma acidental (no caso de um download acidental do malware), ou de forma proposital (em caso de sabotagem). De qualquer forma, faz-se necessário que haja um monitoramento das comunicações dos dispositivos da rede para que possam ser detectadas irregularidades e faz-se necessário estudar como que uma rede de computadores pode ser afetada nesse caso.

\section{O Laboratório virus\_on\_network}

O laboratório virus\_on\_network é um modelo genérico que simula a transmissão de um vírus em uma rede e pode ser utilizado tanto para simular uma infecção viral como uma infecção por um vírus em uma rede de computadores.

Assim, fez-se a oportunidade de realizar um estudo semelhante utilizando esta ferramenta para simular uma "epidemia" em uma rede de computadores.

\subsection{O Conceito da Simulação}

O código base utilizado está presente no repositório do \textit{GitHub} denominado \textit{projectmesa/mesa-examples/Virus\_on\_network} \href{https://github.com/projectmesa/mesa-examples/tree/main/examples/Virus_on_Network}{link para o repositório}.


O modelo foi composto de forma a representar cada sistema de uma rede de conexões como um agente, tendo assim uma rede de agentes interconectados. Dessa forma, desenha-se um grafo onde cada vértice é um dispositivo e as arestas correspondem às conexões entre eles. 

Esse modelo proposto foi então utilizado como base para elaborar uma simulação que retrata a dispersão de um vírus na rede proposta.
Para definir o comportamento desta simulação, o problema foi dividido um conjunto de variáveis, selecionadas de forma a isolar os fatores centrais que definem o comportamento do modelo para o problema escolhido.

%(TBW)
Assim foram selecionadas 5 variáveis dependentes e 8 variáveis independentes. 
    
    \begin{enumerate}
        \item nº de agentes
\item media de nodos vizinhos
    \item numero inicial de infectados
    \item chance de contágio
    \item frequência de checagem por vírus
    \item chance de recuperação
    \item chance de resistencia
    \item numero inicial de \textit{watchdogs}

    \end{enumerate}
    \begin{enumerate}
        \item Infectado
        \item Susceptible
        \item Resistant
        \item Watchdog
        \item Dorment
    \end{enumerate}
    

\subsection{O Simulador}

No código estão presentes as seguintes variáveis:
\begin{description}
\item \textit{num\_nodes} contém o número de agentes presentes no modelo.
\item \textit{avg\_node\_degree} representa o número médio de arestas entre os agentes, ou seja, o número médio de conexões entre os computadores.
\item \textit{initial\_outbreak\_size} define a quantidade inicial de aparelhos infectados.
\item \textit{virus\_spread\_chance} estipula a chance de contágio do vírus.
\item \textit{virus\_check\_frequency} define a frequência com que um watchdog procura por virus em computadores proximos.
\item \textit{recovery\_chance} representa a chance de um computador ser recuperado da infecção.
\item \textit{gain\_resistance\_chance} contém a chance de um agente mudar seu estado para 
\item \textit{resistant}, representando a chance de o usuário do computador ter detectado a infecção e, além de ter mitigado o ataque, ter criado uma proteção.
\item \textit{dorment}, é um computador infectado porém ele esta dormente (não conseguiu estabelecer conexão com outro computador).
\item \textit{watchdog} é o computador responsavel por monitorar os nós proximos.
\end{description}

A seguinte imagem \ref{fig:seraphritt:interface} mostra interface gráfica do modelo:

\begin{figure}[H]
    \centering
    \includegraphics[angle=0,width=1\textwidth]{exploratory-data-analysis/RequiemDosVivos/PesqBibliogr/VirusOnNetwork/req_interface.png}
    \caption{Interface do modelo}
    \label{fig:req_interface}
\end{figure}

\subsubsection{Variáveis Independentes ou de Controle}

São as seguintes as variáveis Independentes ou de Controle, manipuláveis na interface gráfica do simulador:
\begin{description}
\item Number of agents define a quantidade de agentes na simulação, ou seja, o quantidade de vértices no grafo, em um intervalo de 10 a 100.
\item Avg Node Degree é a quantidade média de arestas que cada vértice possui, em um intervalo de 3 a 8.
\item Recovery Chance, define a probabilidade de um agente se recuperar (cor verde) (\textit{suscetible}) dado que está com a cor vermelha (\textit{infected}), em um intervalo de 0 a 1.
\item Gain Resistance Chance, controla a probabilidade de um agente tornar-se resistente (cor cinza) (\textit{resistant}), em um intervalo de 0 a 1.
\item Initial watchdog size, controla a quantidade inicial de watchdogs (cor azul).
\item Initial Outbreak Size controla a quantidade de agentes na cor vermelha (\textit{infected} no primeiro passo da simulação, em um intervalo de 1 a 10.
\item Virus Spread Chance define a probabilidade de um agente infectado infectar seus vizinhos (representado por vermelho, em um intervalo de 0 a 1.
\item Virus Check Frequency controla a probabilidade da simulação mudar o estado de um agente para \textit{infected}, em um intervalo de 0 a 1.
\item Virus spread chance, é usado para determinar se o vírus se espalhou ou não pelo sistema.

\end{description}

\subsubsection{Variáveis Dependentes}

São as seguintes as variáveis Dependentes, cujos valores são coletados e apresentados na interface gráfica do simulador:
\begin{description}
\item Infected representa a quantidade de agentes infectados.
\item Dorment represente infectados que estão dormentes no sistema.
\item Suscetible representa a quantidade de agentes suscetíveis a serem infectados. 
\item Resistant representa a quantidade de agentes resistentes ao vírus, ou seja, mesma que tenham contato com um agente infectado, esses agentes resistentes não serão infectados.
\item Watchdog representa a quantidade de agentes responsáveis por monitorar as atividades da rede.
\end{description}


\subsection{A Hipótese Causal}
Quanto ao comportamento da rede no cenário proposto, houveram as seguintes suposições:

\begin{description}
\item Um malware infectando uma rede altamente conexa consegue infectar mais elementos do que uma rede com baixa conectividade (em questão de topologia)? 
\item Em uma rede que faz uso de dispositivos \textbf{"watchdogs"}, é possível que determinados dispositivos fiquem no "ponto cego" do dispositivo e o comportamento anormal jamais seja mitigado?
\end{description}

Culminando na seguinte hipótese causal : ``a topologia de uma rede pode afetar o processo de mitigação de malwares."


\subsection{O Código do Simulador}

Com o intuito de comprovar a veracidade da hipótese causal, adicionei uma variável independente \textit{Virus Letal Chance} e uma variável dependente \text{Dead} para aprimorar o modelo e assim simular a infecção por vírus com chances de letalidade diferentes. 

As classes presentes no simulador são:
\begin{description}
    \item \textit{State}, classe responsável por controlar o estado de cada agente e possui os atributos \textit{SUSCETIBLE = 0}, \textit{INFECTED = 1}, \textit{RESISTANT = 2}, \textit{WATCHDOG = 3} e \textit{DORMENT = 4}.
    \item \textit{VirusAgent}, classe resposável por declarar os agentes.
    \item \textit{VirusOnNetwork}, classe resposável pelo modelo em si, bem como a coleta de dados. Essa classe instancia os agentes. 
\end{description}



\begin{verbatim}
class State(Enum):
    SUSCEPTIBLE = 0
    INFECTED = 1
    RESISTANT = 2
    WATCHDOG = 3
    DORMENT = 4
    
\end{verbatim}


\textbf{VirusOnNetwork}, trecho do código:

\begin{verbatim}
class VirusOnNetwork(mesa.Model):
    """A virus model with some number of agents"""

    def __init__(
        self,
        num_nodes=10,
        avg_node_degree=3,
        initial_outbreak_size=1,
        virus_spread_chance=0.4,
        virus_check_frequency=0.4,
        recovery_chance=0.3,
        gain_resistance_chance=0.5,
	  initial_watchdog_size=1,
    ):

        self.num_nodes = num_nodes
        prob = avg_node_degree / self.num_nodes
        self.G = nx.erdos_renyi_graph(n=self.num_nodes, p=prob)
        self.grid = mesa.space.NetworkGrid(self.G)
        self.schedule = mesa.time.RandomActivation(self)
        self.initial_outbreak_size = (
            initial_outbreak_size if initial_outbreak_size <= num_nodes else num_nodes
        )
        self.virus_spread_chance = virus_spread_chance
        self.virus_check_frequency = virus_check_frequency
        self.recovery_chance = recovery_chance
        self.gain_resistance_chance = gain_resistance_chance
        self.initial_watchdog_size = (
            initial_watchdog_size if initial_watchdog_size <= num_nodes else num_nodes
        )

        self.datacollector = mesa.DataCollector(
            {
                "Infected": number_infected,
                "Susceptible": number_susceptible,
                "Resistant": number_resistant,
            }
        )

        # Create agents
        for i, node in enumerate(self.G.nodes()):
            a = VirusAgent(
                i,
                self,
                State.SUSCEPTIBLE,
                self.virus_spread_chance,
                self.virus_check_frequency,
                self.recovery_chance,
                self.gain_resistance_chance,
#                self.watchdog,
            )
            self.schedule.add(a)
            # Add the agent to the node
            self.grid.place_agent(a, node)

        # Create some watchdogs
        watchdog_nodes = self.random.sample(list(self.G), self.initial_watchdog_size)
        for a in self.grid.get_cell_list_contents(watchdog_nodes):
            a.state = State.WATCHDOG

        # Infect some nodes
        infected_nodes = self.random.sample(list(self.G), self.initial_outbreak_size)
        for a in self.grid.get_cell_list_contents(infected_nodes):
            a.state = State.INFECTED


        self.running = True
        self.datacollector.collect(self)

    def resistant_susceptible_ratio(self):
        try:
            return number_state(self, State.RESISTANT) / number_state(
                self, State.SUSCEPTIBLE
            )
        except ZeroDivisionError:
            return math.inf

    def step(self):
        self.schedule.step()
        # collect data
        self.datacollector.collect(self)

    def run_model(self, n):
        for i in range(n):
            self.step()
\end{verbatim}


\textbf{VirusAgent}, alguns comportamentos são descritos aqui, como dorment() e \textit{try\_remove\_infection()}, que foi alterado para realizar o comportamento desejado. 

\begin{verbatim}
class VirusAgent(mesa.Agent):
    def __init__(
        self,
        unique_id,
        model,
        initial_state,
        virus_spread_chance,
        virus_check_frequency,
        recovery_chance,
        gain_resistance_chance,
    ):
        super().__init__(unique_id, model)

        self.state = initial_state

        self.virus_spread_chance = virus_spread_chance
        self.virus_check_frequency = virus_check_frequency
        self.recovery_chance = recovery_chance
        self.gain_resistance_chance = gain_resistance_chance

    def try_to_infect_neighbors(self):
        neighbors_nodes = self.model.grid.get_neighbors(self.pos, include_center=False)
        susceptible_neighbors = [
            agent
            for agent in self.model.grid.get_cell_list_contents(neighbors_nodes)
            if agent.state is State.SUSCEPTIBLE or agent.state is State.DORMENT
        ]
        for a in susceptible_neighbors:
            if a.state is State.SUSCEPTIBLE:
                if self.random.random() < self.virus_spread_chance:
                    a.state = State.INFECTED
            if a.state is State.DORMENT:
                a.state = State.INFECTED

    def try_gain_resistance(self):
        if self.random.random() < self.gain_resistance_chance:
            self.state = State.RESISTANT

    def try_remove_infection(self):
        # Try to remove
        neighbors_nodes = self.model.grid.get_neighbors(self.pos, include_center=False)
        infected_neighbors = [
            agent
            for agent in self.model.grid.get_cell_list_contents(neighbors_nodes)
            if agent.state is State.INFECTED or agent.state is State.DORMENT
        ]

        for neighbor in infected_neighbors:
             if self.random.random() < self.recovery_chance:
                 neighbor.state = State.SUSCEPTIBLE
                 neighbor.try_gain_resistance()

    def try_check_situation(self):
        if self.random.random() < self.virus_check_frequency:
            # Checking...
            if self.state is State.WATCHDOG:
                self.try_remove_infection()



    def dorment(self):
        neighbors_nodes = self.model.grid.get_neighbors(self.pos, include_center=False)
        state_neighbors = [
            agent
            for agent in self.model.grid.get_cell_list_contents(neighbors_nodes)
            if agent.state is State.INFECTED or agent.state is State.SUSCEPTIBLE
        ]
        if len(state_neighbors)==0:
            self.state = State.DORMENT
            


    def step(self):
        if self.state is State.INFECTED:
            self.try_to_infect_neighbors()
            self.dorment()
        self.try_check_situation()
\end{verbatim}


\section{Os Experimentos Realizados}

Foram feitos 2 experimentos principais para verificar a veracidade da hipótese causal:
\begin{description}

\item Experimento I: A variável \textit{Avg Node Degree} com o valor máximo e as outras variáveis com um valor aleatórios (diversas amostras) e depois com o menor valor possível. Objetivo, ver o impacto da variável no modelo de simulação.
\item Experimento II: A variável \textit{Initial Watchdog Size} com o valor máximo, mínimo e depois cerca de 10\% do valor de \textit{Number of agents}, com \textit{Virus Spread Chance} mínimo, médio e máximo. Esse experimento teve intuito de verificar o impacto que os watchdogs tem em relação a infecção (os demais atributos foram de valores aleatórios).

\end{description}


Além desses experimentos foram feitos outros experimentos para tentar encontrar pontos chaves em que o sistema conseguisse maior numero de infectados ou menor numero de infectados. 

A baixo temos dois gráficos, um realizando o experimento com baixa conectividade e outro realizando com o máximo de conectividade

\begin{figure}[H]
    \centering
    \includegraphics[angle=0,width=1\textwidth]{exploratory-data-analysis/RequiemDosVivos/PesqBibliogr/VirusOnNetwork/req_highconect.png}
    \caption{Gráfico Alta Conectividade}
    \label{fig:req_highconect}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[angle=0,width=1\textwidth]{exploratory-data-analysis/RequiemDosVivos/PesqBibliogr/VirusOnNetwork/req_lowconect.png}
    \caption{Gráfico Baixa Conectividade}
    \label{fig:req_lowconect}
\end{figure}



\section{Discussão e \textit{insights} preliminares sobre as hipóteses}


Levando em conta os resultados obtidos com o sistema simplificado proposto para a simulação, vê-se uma série de comportamentos interessantes.

Primeiro vê-se que como proposto na hipótese causal, a topologia afetou significativamente o numero de maquinas que se infectaram e a velocidade com a qual a mitigação ocorria.

Verificou-se que ao contrário do que se esperava, redes de menor porte com menor inter-conectividade tiveram maior numero de maquinas que permaneceram infectadas após atuação dos watchdogs.

Também se constatou que ainda houveram máquinas infectadas que continuaram se comunicando após a tentativa de mitigação em determinados casos, e que isso está realmente mais relacionado com o a presença de menores números de dispositivos watchdogs.

Por fim, faz-se válido comentar que houveram dispositivos que nunca chegaram a ser infectados pelo vírus, sendo por que apenas estavam conectados com as watchdogs ou porque estes tornaram o único caminho até uma maquina isolada resistente.


\section{Conclusão}

Conseguimos confirmar algumas hipóteses enquanto outras foram negadas por nossos experimentos. É interessante ressaltar que apesar do fato de que as redes com alta conectividade (topologicamente) foram as redes com menor numero de infectados finais elas também foram as redes com maior pico de infectados, talvez isso implique que elas são redes com melhor recuperação dos sistemas mas são redes mais suscetíveis a ataques quando comparadas a redes com baixa conectividade.

